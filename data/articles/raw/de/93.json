{"title": "Softwareentwicklung: Kooperatives Unterbrechen eines Threads in C++20", "timestamp": "2024-07-01T09:48:00Z", "content": "\n\n\n        Vor C++20 lie\u00dfen sich Threads nicht unterbrechen. Mit C++20 kann man an einen Thread die Anfrage stellen, dass er sich beendet. Ihr kann er dann nachkommen. \n      \n\n      (Bild:\u00a0Patrick Poendl/Shutterstock.com)\n    \nDieser Artikel ist eine Wiederholung eines Beitrags, den ich urspr\u00fcnglich vor dreieinhalb Jahre geschrieben habe. Ich ben\u00f6tige ihn als Einstieg f\u00fcr den n\u00e4chsten Artikel. Daher habe ich mich entschieden, den Beitrag nochmals zu ver\u00f6ffentlichen.\n\n          Rainer Grimm ist seit vielen Jahren als Softwarearchitekt, Team- und Schulungsleiter t\u00e4tig. Er schreibt gerne Artikel zu den Programmiersprachen C++, Python und Haskell, spricht aber auch gerne und h\u00e4ufig auf Fachkonferenzen. Auf seinem Blog Modernes C++ besch\u00e4ftigt er sich intensiv mit seiner Leidenschaft C++.\n        \nZuerst einmal: Warum ist es keine gute Idee, einen Thread zu beenden? Diese Antwort ist einfach. Man wei\u00df nicht, in welchem Zustand der Thread ist, wenn man ihn beendet. Dies sind zwei m\u00f6gliche Gefahren:\nEinen Thread abrupt zu unterbrechen, ist keine gute Idee. Da ist es schon besser, den Thread freundlich zu fragen, ob er sich beenden lassen will. Das ist genau, wof\u00fcr kooperatives Unterbrechen in C++20 steht. Man fragt den Thread freundlich, ob er sich beenden will, und der Thread kann diesem Wunsch nachkommen oder ihn ignorieren.\nDie zus\u00e4tzliche F\u00e4higkeit der kooperativen Unterbrechung in C++20 basiert auf den drei neuen Datentypen std::stop_token, std::stop_callback und std::stop_source. Sie erm\u00f6glichen es einem Thread, einen Thread asynchron zu beenden oder zu fragen, ob ein Thread ein Stoppsignal erhalten hat. Der std::stop_token l\u00e4sst sich daf\u00fcr an eine Operation \u00fcbergeben. Dieses Stopp-Token kann anschlie\u00dfend dazu verwendet werden, die Operation zu fragen, ob an sie der Wunsch zur Beendigung geschickt wurde. Anderseits l\u00e4sst sich mit std::stop_token ein Callback mittels std::stop_callback registrieren. Die Stoppanfrage wird von std::stop_source geschickt. Ihr Signal betrifft alle assoziierten std::stop_token. Die drei Klassen std::stop_source, std::stop_token und std::stop_callback teilen sich die Besitzverh\u00e4ltnisse des assoziierten Stoppzustands. Die Aufrufe request_stop(), stop_requested() und stop_possible() sind atomar. \nEin std::stop_source l\u00e4sst sich auf zwei Arten erzeugen:\nDer Default-Konstruktor (1) erzeugt ein std::stop_source mit einem Stoppzustand. Der Konstruktor, der std::nostopstate_t als Argument annimmt, erzeugt eine std::stop_source ohne assoziierten Stoppzustand.\nDie Komponente std::stop_source src bietet die folgenden Methoden an, um mit Stoppanfragen umzugehen:\nsrc.stop_possible() bedeutet, dass src einen assoziierten Stoppzustand besitzt. src.stop_requested() gibt dann true zur\u00fcck, wenn src einen assoziierten Stoppzustand besitzt und nicht bereits fr\u00fcher zu stoppen angefordert wurde. Der Aufruf src.get_token() gibt den Stopp-Token zur\u00fcck. Dank ihm l\u00e4sst sich pr\u00fcfen, ob eine Stoppanfrage bereits erfolgt ist oder durchgef\u00fchrt werden kann.\nDas Stopp-Token stoken beobachtet die Stoppquelle src. Die folgende Tabelle stellt die Methoden der std::stop_token stoken vor:\nEin Default-konstruiertes Token besitzt keinen assoziierten Stoppzustand. stoken.stop_possible gibt true zur\u00fcck, falls stoken einen assoziierten Stoppzustand besitzt. stoken_stop_requested() gibt dann true zur\u00fcck, wenn der Stopp-Token einen assoziierten Stoppzustand besitzt und bereits eine Stoppanfrage erhalten hat.\nFalls der std::stop_token zeitweise deaktiviert werden soll, l\u00e4sst er sich mit einem Default-konstruierten Token ersetzen. Dieses hat keinen assoziierten Stoppzustand. Die folgenden Zeilen zeigen, wie sich die F\u00e4higkeit eines Threads, Stoppanfragen zu erhalten, zeitweise deaktivieren l\u00e4sst:\nstd::stop_token interruptDisabled besitzt keinen assoziierten Stoppzustand. Das hei\u00dft, dass der Thread jthr in allen Zeilen au\u00dfer (1) und (2) Stoppanfragen annehmen kann.\nWer den Codeschnipsel sorgf\u00e4ltig studiert, dem f\u00e4llt wohl std::jthread auf. std::jthread in C++20 ist ein erweiterter std::thread aus C++11. Das \"j\" in jthread steht f\u00fcr joinable, denn ein std::jthread joint automatisch in seinem Destruktor. Urspr\u00fcnglich hie\u00df dieser neue Thread ithread: \"i\" steht f\u00fcr interruptable. Ich stelle std::jthread im n\u00e4chsten Artikel genauer vor. \nDas n\u00e4chste Beispiel zeigt, wie sich std::jthread zusammen mit einem Callback verwenden l\u00e4sst:\nJeder der zehn Threads ruft die Lambda-Funktion func (1) auf. Der Callback (2) stellt die ID des Threads und den Z\u00e4hler dar. Dank des einsekundigen Schlafens des main-Threads (3) und des Schlafens der Kinder-Threads besitzt der Z\u00e4hler zum Zeitpunkt des Callback-Aufrufs den Wert 4. Der Aufruf thr.request_stop() (4) startet den Callback auf jedem Thread.\n\n\n(rme)\n\n\n\n    montags und donnerstags - alles von heise Developer\n  \n\n    Ausf\u00fchrliche Informationen zum Versandverfahren und zu Ihren\n    Widerrufsm\u00f6glichkeiten erhalten Sie in unserer\n    Datenschutzerkl\u00e4rung.\n  \n\nImmer informiert bleiben: Klicken Sie auf das Plus-Symbol an einem Thema, um diesem zu folgen. Wir zeigen Ihnen alle neuen Inhalte zu Ihren Themen.\n\n          Mehr erfahren.\n        \n\n\nExklusive Tests, Ratgeber & Hintergr\u00fcnde. Unbegrenzter Zugriff auf alle heise+ Beitr\u00e4ge inkl. allen Digital-Magazinen.", "language": "de"}